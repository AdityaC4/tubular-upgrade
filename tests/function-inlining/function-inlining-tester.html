<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Function Inlining Tests</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      .nav {
        background-color: #f5f5f5;
        border-radius: 4px;
        padding: 8px 12px;
        margin: 12px 0;
      }
      .nav a {
        margin-right: 12px;
        text-decoration: none;
        color: #0366d6;
      }
      .nav a.active {
        font-weight: bold;
        color: #000;
      }
      .test {
        margin-bottom: 20px;
      }
      .test-group {
        border: 1px solid #ddd;
        border-radius: 5px;
        margin: 20px 0;
        padding: 15px;
      }
      .test-group h3 {
        margin-top: 0;
        color: #333;
      }
      .inline-row {
        background-color: #f9f9f9;
        border-left: 4px solid #007acc;
      }
      .with-inlining {
        background-color: #f0fff0;
      }
      .without-inlining {
        background-color: #fff8dc;
      }
      .error {
        color: red;
        font-weight: bold;
      }
      .pass {
        color: darkgreen;
        font-weight: bold;
      }
      .fail {
        color: darkred;
        font-weight: bold;
      }
      .waiting {
        color: gray;
        font-style: italic;
      }
      .performance-info {
        font-size: 0.9em;
        color: #666;
        font-style: italic;
      }
      .summary-box {
        background-color: #e8f4f8;
        border: 1px solid #bee5eb;
        border-radius: 5px;
        padding: 15px;
        margin: 20px 0;
      }
      .time-comparison {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .time-badge {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
      }
      .faster {
        background-color: #d4edda;
        color: #155724;
      }
      .slower {
        background-color: #f8d7da;
        color: #721c24;
      }
      .same {
        background-color: #e2e3e5;
        color: #383d41;
      }
    </style>
  </head>
  <body>
    <h1>Function Inlining Tests</h1>

    <div class="nav">
      <a href="../index.html">Project 4 Tests</a>
      <a href="../P3-tester.html">Project 3 Tests</a>
      <a
        class="active"
        href="../function-inlining/function-inlining-tester.html"
        >Function Inlining Tests</a
      >
      <a href="../loop-unrolling/loop-unrolling-tester.html"
        >Loop Unrolling Tests</a
      >
      <a href="../tail-recursion/tail-recursion-tester.html"
        >Tail Recursion Tests</a
      >
    </div>

    <!-- About section moved below results -->

    <table id="results-table">
      <tr style="height: 30px">
        <td style="background-color: #ddddff" colspan="7">
          <div id="test-summary">
            <b>TESTS:</b>
            <b><span class="total_count">0</span></b> &nbsp;&nbsp;&nbsp;
            <b>PASSED:</b>
            <span class="pass_count pass">0</span> &nbsp;&nbsp;&nbsp;
            <b>FAILED:</b>
            <span class="fail_count fail">0</span> &nbsp;&nbsp;&nbsp;
            <b>ERRORS:</b> <span class="error_count error">0</span>
          </div>
        </td>
      </tr>
      <tr style="background-color: #dddddd">
        <th>Test File</th>
        <th>Function</th>
        <th>Inlining</th>
        <th>Status</th>
        <th>Output</th>
        <th>Expected</th>
        <th>Performance</th>
      </tr>
    </table>

    <div class="summary-box" style="margin-top: 20px">
      <h3 style="margin-top: 0">About These Tests</h3>
      <p>
        Compares execution time and correctness with function inlining disabled
        versus enabled. Each row reports median per‑call time after warm‑up;
        percent change is relative to the no‑inline baseline.
      </p>
      <ul>
        <li>Timing: median of 3 runs; iterations per test may vary.</li>
        <li>Warm‑up: 10 iterations to stabilize JIT.</li>
        <li>Correctness: exact match with expected output.</li>
      </ul>
    </div>

    <script>
      // Test configurations for function inlining tests
      const testConfigs = [
        {
          file: "inline-test-01",
          name: "BasicArithmetic",
          function: "main",
          args: [],
          expected: 10,
          description: "Simple arithmetic function - double_it(5)",
          iterations: 1000,
        },
        {
          file: "inline-test-02",
          name: "MultipleInlines",
          function: "main",
          args: [],
          expected: 32,
          description: "Multiple function calls in sequence",
          iterations: 1000,
        },
        {
          file: "inline-test-03",
          name: "NestedCalls",
          function: "main",
          args: [],
          expected: 14,
          description: "Nested function calls - factorial-like computation",
          iterations: 1000,
        },
        {
          file: "inline-test-04",
          name: "ConditionalInlining",
          function: "main",
          args: [],
          expected: 88,
          description: "Functions with conditional logic",
          iterations: 1000,
        },
        {
          file: "inline-test-05",
          name: "StringOperations",
          function: "main",
          args: [],
          expected: 42,
          description: "String manipulation functions",
          iterations: 1000,
        },
        {
          file: "inline-test-06",
          name: "ComplexExpression",
          function: "main",
          args: [],
          expected: 15,
          description: "Complex mathematical expressions with multiple inlines",
          iterations: 1000,
        },
        // Performance-focused tests to show inlining impact clearly
        {
          file: "inline-perf-01",
          name: "HotLoop_Inc",
          function: "main",
          args: [],
          expected: 5000000,
          description: "5M calls to a tiny function inside a hot loop",
          iterations: 5,
          warmupIterations: 2,
        },
        {
          file: "inline-perf-02",
          name: "HotLoop_CallChain",
          function: "main",
          args: [],
          expected: 30000000,
          description: "3M iterations of a 4-deep small call chain",
          iterations: 5,
          warmupIterations: 2,
        },
        {
          file: "inline-perf-03",
          name: "HotLoop_Paramless",
          function: "main",
          args: [],
          expected: 28000000,
          description: "4M calls to a parameterless function in a hot loop",
          iterations: 5,
          warmupIterations: 2,
        },
      ];

      const inliningModes = [
        { suffix: "-no-inline", name: "Without Inlining", enabled: false },
        { suffix: "-inline", name: "With Inlining", enabled: true },
      ];

      // Summary counters
      let test_count = 0;
      let pass_count = 0;
      let fail_count = 0;
      let error_count = 0;

      // Performance tracking
      const performanceData = {};
      // Cache rows to retroactively attach badges when baseline arrives
      const rowsByFileMode = {}; // file -> { 'no-inline': row, 'inline': row }

      function updateSummary() {
        const summary_div = document.getElementById("test-summary");
        const tot_span = summary_div.querySelector(".total_count");
        tot_span.textContent = test_count;
        const pass_span = summary_div.querySelector(".pass_count");
        pass_span.textContent = pass_count;
        const fail_span = summary_div.querySelector(".fail_count");
        fail_span.textContent = fail_count;
        const error_span = summary_div.querySelector(".error_count");
        error_span.textContent = error_count;
      }

      function formatTime(ms) {
        if (ms < 1000) {
          return `${ms.toFixed(2)}ms`;
        } else {
          return `${(ms / 1000).toFixed(3)}s`;
        }
      }

      function getPerformanceClass(baseTime, currentTime, isInlined) {
        if (!baseTime || !currentTime) return "same";
        const diff = ((currentTime - baseTime) / baseTime) * 100;
        if (!isInlined) return "same"; // Baseline shows as "same"
        return diff > 0 ? "slower" : "faster";
      }

      function getPerformanceText(baseTime, currentTime, isInlined) {
        if (!baseTime || !currentTime || !isInlined) return "";
        const diff = ((currentTime - baseTime) / baseTime) * 100;
        const symbol = diff > 0 ? "+" : "";
        return `${symbol}${diff.toFixed(1)}%`;
      }

      // Update badges on rows when baseline becomes available
      function refreshInliningPerformance(file) {
        const data = performanceData[file];
        if (!data || !data["no-inline"]) return;
        const baseTime = data["no-inline"];
        const rows = rowsByFileMode[file] || {};

        for (const modeKey of ["no-inline", "inline"]) {
          const row = rows[modeKey];
          const time = data[modeKey];
          if (!row || !time) continue;

          const statusCell = row.cells[3];
          const performanceCell = row.cells[6];
          const timeText = formatTime(time);

          if (statusCell.textContent === "PASS") {
            if (modeKey === "inline") {
              const perfClass = getPerformanceClass(baseTime, time, true);
              const perfText = getPerformanceText(baseTime, time, true);
              performanceCell.innerHTML = `
                <div class="time-comparison">
                  <span>${timeText}</span>
                  <span class="time-badge ${perfClass}">${perfText}</span>
                </div>
              `;
            } else {
              performanceCell.textContent = timeText;
            }
          } else {
            performanceCell.textContent = timeText;
          }
        }
      }

      // Function to load and test each WASM file
      async function runTest(testConfig, mode, table_row) {
        const filename = `${testConfig.file}${mode.suffix}.wasm`;

        try {
          test_count++;
          updateSummary();

          // Update status to show progress
          const status_cell = table_row.cells[3];
          status_cell.textContent = "Loading...";
          status_cell.className = "result waiting";

          // Fetch the WASM file
          const response = await fetch(filename);
          if (!response.ok) {
            throw new Error(`Missing file ${filename}`);
          }
          const wasmBuffer = await response.arrayBuffer();
          const wasmModule = await WebAssembly.instantiate(wasmBuffer);

          // Update status to show testing in progress
          status_cell.textContent = "Testing...";

          // Execute the function multiple times to get more reliable timing
          const iterations = testConfig.iterations ?? 1000;
          const warmupIterations = testConfig.warmupIterations ?? 10;

          // Warm-up phase to stabilize JIT compilation
          for (let i = 0; i < warmupIterations; i++) {
            wasmModule.instance.exports[testConfig.function].apply(
              null,
              testConfig.args
            );
          }

          // Force garbage collection if available (Chrome DevTools)
          if (window.gc) {
            window.gc();
          }

          // Actual measurement phase with multiple runs
          const measurements = [];
          const runs = 3;

          for (let run = 0; run < runs; run++) {
            const runStartTime = performance.now();
            let checksum = 0; // Prevent dead code elimination

            for (let i = 0; i < iterations; i++) {
              result = wasmModule.instance.exports[testConfig.function].apply(
                null,
                testConfig.args
              );
              checksum ^= result; // XOR to prevent optimization while staying fast
            }

            const runEndTime = performance.now();
            measurements.push((runEndTime - runStartTime) / iterations);

            // Use checksum to prevent dead code elimination
            if (checksum === 0x12345678) console.log("Impossible checksum");
          }

          // Use median of measurements to reduce noise
          measurements.sort((a, b) => a - b);
          const avgExecutionTime =
            measurements[Math.floor(measurements.length / 2)];

          // Store performance data
          if (!performanceData[testConfig.file]) {
            performanceData[testConfig.file] = {};
          }
          performanceData[testConfig.file][
            mode.enabled ? "inline" : "no-inline"
          ] = avgExecutionTime;

          // Update table cells
          const output_cell = table_row.cells[4];
          const expected_cell = table_row.cells[5];
          const performance_cell = table_row.cells[6];

          output_cell.textContent = result;
          expected_cell.textContent = testConfig.expected;
          performance_cell.textContent = formatTime(avgExecutionTime);

          // Check the result against expected output
          if (result === testConfig.expected) {
            status_cell.textContent = "PASS";
            status_cell.className = "result pass";
            pass_count++;

            // Add performance comparison for inlined version
            if (mode.enabled && performanceData[testConfig.file]["no-inline"]) {
              const baseTime = performanceData[testConfig.file]["no-inline"];
              const perfClass = getPerformanceClass(
                baseTime,
                avgExecutionTime,
                mode.enabled
              );
              const perfText = getPerformanceText(
                baseTime,
                avgExecutionTime,
                mode.enabled
              );

              performance_cell.innerHTML = `
                <div class="time-comparison">
                  <span>${formatTime(avgExecutionTime)}</span>
                  <span class="time-badge ${perfClass}">${perfText}</span>
                </div>
              `;
            }
            // Refresh possible badges when either mode completes
            refreshInliningPerformance(testConfig.file);
          } else {
            status_cell.textContent = "FAIL";
            status_cell.className = "result fail";
            fail_count++;
          }

          updateSummary();
        } catch (error) {
          // Display any error
          const status_cell = table_row.cells[3];
          status_cell.textContent = "ERROR";
          status_cell.className = "result error";

          const output_cell = table_row.cells[4];
          output_cell.colSpan = 3;
          output_cell.textContent = `ERROR: ${error.message}`;

          error_count++;
          updateSummary();
        }
      }

      /* function createPerformanceSummary() {
        const summaryDiv = document.getElementById("performance-summary");
        let summaryHTML =
          '<div class="summary-box"><h3>Performance Summary</h3>';

        for (const [testFile, data] of Object.entries(performanceData)) {
          const testConfig = testConfigs.find(
            (config) => config.file === testFile
          );
          if (!testConfig) continue;

          summaryHTML += `<div class="test-group">`;
          summaryHTML += `<h4>${testConfig.name}</h4>`;
          summaryHTML += `<p class="performance-info">${testConfig.description}</p>`;

          if (data['no-inline'] && data['inline']) {
            summaryHTML +=
              '<table style="width: 100%; border-collapse: collapse;">';
            summaryHTML +=
              '<tr style="background-color: #f0f0f0;"><th style="padding: 5px; border: 1px solid #ddd;">Mode</th><th style="padding: 5px; border: 1px solid #ddd;">Avg Time</th><th style="padding: 5px; border: 1px solid #ddd;">vs Baseline</th></tr>';

            const baseTime = data['no-inline'];
            const inlineTime = data['inline'];

            // No-inline row
            summaryHTML += `<tr>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;">Without Inlining</td>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;">${formatTime(baseTime)}</td>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;"><span class="time-badge same">Baseline</span></td>`;
            summaryHTML += `</tr>`;

            // Inline row
            const perfText = getPerformanceText(baseTime, inlineTime, true);
            const perfClass = getPerformanceClass(baseTime, inlineTime, true);
            
            summaryHTML += `<tr>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;">With Inlining</td>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;">${formatTime(inlineTime)}</td>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;"><span class="time-badge ${perfClass}">${perfText}</span></td>`;
            summaryHTML += `</tr>`;

            summaryHTML += "</table>";
          }
          summaryHTML += "</div>";
        }

        summaryHTML += "</div>";
        summaryDiv.innerHTML = summaryHTML;
      } */

      // Run tests asynchronously
      function runTestsAsync() {
        const results_table = document.getElementById("results-table");

        for (const testConfig of testConfigs) {
          // Add a header row for each test group
          const headerRow = results_table.insertRow();
          headerRow.style.backgroundColor = "#e9ecef";
          headerRow.style.fontWeight = "bold";
          const headerCell = headerRow.insertCell(0);
          headerCell.colSpan = 7;
          headerCell.textContent = `${testConfig.name} - ${testConfig.description}`;

          for (const mode of inliningModes) {
            const row = results_table.insertRow();
            row.classList.add(
              "inline-row",
              mode.enabled ? "with-inlining" : "without-inlining"
            );

            // Test file
            const fileCell = row.insertCell(0);
            fileCell.textContent = `${testConfig.file}${mode.suffix}.wasm`;

            // Function name
            const funcCell = row.insertCell(1);
            funcCell.textContent = testConfig.function;

            // Inlining mode
            const modeCell = row.insertCell(2);
            modeCell.textContent = mode.name;
            modeCell.style.fontWeight = "bold";

            // Status
            const statusCell = row.insertCell(3);
            statusCell.textContent = "Waiting...";
            statusCell.className = "result waiting";

            // Output
            row.insertCell(4);

            // Expected
            row.insertCell(5);

            // Performance
            row.insertCell(6);

            // Run the test asynchronously and cache rows for later refresh
            if (!rowsByFileMode[testConfig.file])
              rowsByFileMode[testConfig.file] = {};
            rowsByFileMode[testConfig.file][
              mode.enabled ? "inline" : "no-inline"
            ] = row;
            runTest(testConfig, mode, row);
          }
        }

        // (No separate performance summary section)
      }

      // Start the tests
      runTestsAsync();
    </script>
  </body>
</html>
