<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Function Inlining Tests</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      .test {
        margin-bottom: 20px;
      }
      .test-group {
        border: 1px solid #ddd;
        border-radius: 5px;
        margin: 20px 0;
        padding: 15px;
      }
      .test-group h3 {
        margin-top: 0;
        color: #333;
      }
      .inline-row {
        background-color: #f9f9f9;
        border-left: 4px solid #007acc;
      }
      .with-inlining {
        background-color: #f0fff0;
      }
      .without-inlining {
        background-color: #fff8dc;
      }
      .error {
        color: red;
        font-weight: bold;
      }
      .pass {
        color: darkgreen;
        font-weight: bold;
      }
      .fail {
        color: darkred;
        font-weight: bold;
      }
      .waiting {
        color: gray;
        font-style: italic;
      }
      .performance-info {
        font-size: 0.9em;
        color: #666;
        font-style: italic;
      }
      .summary-box {
        background-color: #e8f4f8;
        border: 1px solid #bee5eb;
        border-radius: 5px;
        padding: 15px;
        margin: 20px 0;
      }
      .time-comparison {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .time-badge {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
      }
      .faster {
        background-color: #d4edda;
        color: #155724;
      }
      .slower {
        background-color: #f8d7da;
        color: #721c24;
      }
      .same {
        background-color: #e2e3e5;
        color: #383d41;
      }
    </style>
  </head>
  <body>
    <h1>Function Inlining Tests</h1>

    <div class="summary-box">
      <h3 style="margin-top: 0">About Function Inlining Tests</h3>
      <p>
        These tests measure the performance impact and correctness of function 
        inlining optimization. Function inlining can improve performance by:
      </p>
      <ul>
        <li>
          <strong>Eliminating Call Overhead:</strong> Removes function call/return instructions
        </li>
        <li>
          <strong>Enabling Further Optimizations:</strong> Allows cross-function optimizations
        </li>
        <li>
          <strong>Reducing Stack Operations:</strong> Fewer stack frame operations
        </li>
      </ul>
      <div
        style="
          background-color: #fff3cd;
          border: 1px solid #ffeaa7;
          border-radius: 3px;
          padding: 10px;
          margin: 10px 0;
        "
      >
        <strong>ðŸ”§ Test Configuration:</strong>
        <ul style="margin: 5px 0">
          <li>Each test is compiled with and without function inlining</li>
          <li>Performance measured using median of 3 runs with 1000 iterations each</li>
          <li>Correctness verified by comparing expected outputs</li>
          <li>Tests cover various inlining scenarios and edge cases</li>
        </ul>
      </div>
      <p class="performance-info">
        <strong>Note:</strong> Function inlining optimization applies compiler heuristics 
        to decide which functions to inline based on size, complexity, and call frequency.
        Some functions may not be inlined if they exceed complexity thresholds.
      </p>
    </div>

    <div
      style="
        margin: 20px 0;
        padding: 15px;
        background-color: #f0f8ff;
        border-radius: 5px;
      "
    >
      <h3 style="margin-top: 0">Test Suites:</h3>
      <ul style="list-style-type: none; padding: 0">
        <li style="margin: 8px 0">
          <a href="../index.html">ðŸ”„ Project 4 Tests</a> - Main functional tests
        </li>
        <li style="margin: 8px 0">
          <a href="../P3-tester.html">ðŸ“‹ Project 3 Tests</a> - Legacy
          compatibility tests
        </li>
        <li style="margin: 8px 0">
          <a href="../loop-unrolling/loop-unrolling-tester.html">âš¡ Loop Unrolling Tests</a> - Loop optimization tests
        </li>
        <li style="margin: 8px 0">
          <strong>ðŸ”§ Function Inlining Tests</strong> - Current page (function inlining optimization)
        </li>
      </ul>
      <hr style="margin: 15px 0" />
      <p style="margin: 0; font-size: 0.9em; color: #666">
        <strong>Current Page:</strong> Tests function inlining optimization to measure 
        performance improvements and validate that function behavior is preserved.
      </p>
    </div>

    <table id="results-table">
      <tr style="height: 30px">
        <td style="background-color: #ddddff" colspan="7">
          <div id="test-summary">
            <b>TESTS:</b>
            <b><span class="total_count">0</span></b> &nbsp;&nbsp;&nbsp;
            <b>PASSED:</b>
            <span class="pass_count pass">0</span> &nbsp;&nbsp;&nbsp;
            <b>FAILED:</b>
            <span class="fail_count fail">0</span> &nbsp;&nbsp;&nbsp;
            <b>ERRORS:</b> <span class="error_count error">0</span>
          </div>
        </td>
      </tr>
      <tr style="background-color: #dddddd">
        <th>Test File</th>
        <th>Function</th>
        <th>Inlining</th>
        <th>Status</th>
        <th>Output</th>
        <th>Expected</th>
        <th>Performance</th>
      </tr>
    </table>

    <div id="performance-summary" style="margin-top: 20px"></div>

    <script>
      // Test configurations for function inlining tests
      const testConfigs = [
        {
          file: "inline-test-01",
          name: "BasicArithmetic",
          function: "main",
          args: [],
          expected: 10,
          description: "Simple arithmetic function - double_it(5)",
        },
        {
          file: "inline-test-02", 
          name: "MultipleInlines",
          function: "main",
          args: [],
          expected: 32,
          description: "Multiple function calls in sequence",
        },
        {
          file: "inline-test-03",
          name: "NestedCalls",
          function: "main", 
          args: [],
          expected: 14,
          description: "Nested function calls - factorial-like computation",
        },
        {
          file: "inline-test-04",
          name: "ConditionalInlining",
          function: "main",
          args: [],
          expected: 88,
          description: "Functions with conditional logic",
        },
        {
          file: "inline-test-05",
          name: "StringOperations",
          function: "main",
          args: [],
          expected: 42,
          description: "String manipulation functions",
        },
        {
          file: "inline-test-06",
          name: "ComplexExpression",
          function: "main",
          args: [],
          expected: 15,
          description: "Complex mathematical expressions with multiple inlines",
        },
      ];

      const inliningModes = [
        { suffix: "-no-inline", name: "Without Inlining", enabled: false },
        { suffix: "-inline", name: "With Inlining", enabled: true }
      ];

      // Summary counters
      let test_count = 0;
      let pass_count = 0;
      let fail_count = 0;
      let error_count = 0;

      // Performance tracking
      const performanceData = {};

      function updateSummary() {
        const summary_div = document.getElementById("test-summary");
        const tot_span = summary_div.querySelector(".total_count");
        tot_span.textContent = test_count;
        const pass_span = summary_div.querySelector(".pass_count");
        pass_span.textContent = pass_count;
        const fail_span = summary_div.querySelector(".fail_count");
        fail_span.textContent = fail_count;
        const error_span = summary_div.querySelector(".error_count");
        error_span.textContent = error_count;
      }

      function formatTime(ms) {
        if (ms < 1000) {
          return `${ms.toFixed(2)}ms`;
        } else {
          return `${(ms / 1000).toFixed(3)}s`;
        }
      }

      function getPerformanceClass(baseTime, currentTime, isInlined) {
        if (!baseTime || !currentTime) return "same";
        const diff = ((currentTime - baseTime) / baseTime) * 100;
        if (!isInlined) return "same"; // Baseline shows as "same"
        return diff > 0 ? "slower" : "faster";
      }

      function getPerformanceText(baseTime, currentTime, isInlined) {
        if (!baseTime || !currentTime || !isInlined) return "";
        const diff = ((currentTime - baseTime) / baseTime) * 100;
        const symbol = diff > 0 ? "+" : "";
        return `${symbol}${diff.toFixed(1)}%`;
      }

      // Function to load and test each WASM file
      async function runTest(testConfig, mode, table_row) {
        const filename = `${testConfig.file}${mode.suffix}.wasm`;

        try {
          test_count++;
          updateSummary();

          // Update status to show progress
          const status_cell = table_row.cells[3];
          status_cell.textContent = "Loading...";
          status_cell.className = "result waiting";

          // Fetch the WASM file
          const response = await fetch(filename);
          if (!response.ok) {
            throw new Error(`Missing file ${filename}`);
          }
          const wasmBuffer = await response.arrayBuffer();
          const wasmModule = await WebAssembly.instantiate(wasmBuffer);

          // Update status to show testing in progress
          status_cell.textContent = "Testing...";

          // Execute the function multiple times to get more reliable timing
          const iterations = 1000;
          const warmupIterations = 10;

          // Warm-up phase to stabilize JIT compilation
          for (let i = 0; i < warmupIterations; i++) {
            wasmModule.instance.exports[testConfig.function].apply(
              null,
              testConfig.args
            );
          }

          // Force garbage collection if available (Chrome DevTools)
          if (window.gc) {
            window.gc();
          }

          // Actual measurement phase with multiple runs
          const measurements = [];
          const runs = 3;

          for (let run = 0; run < runs; run++) {
            const runStartTime = performance.now();
            let checksum = 0; // Prevent dead code elimination

            for (let i = 0; i < iterations; i++) {
              result = wasmModule.instance.exports[testConfig.function].apply(
                null,
                testConfig.args
              );
              checksum ^= result; // XOR to prevent optimization while staying fast
            }

            const runEndTime = performance.now();
            measurements.push((runEndTime - runStartTime) / iterations);

            // Use checksum to prevent dead code elimination
            if (checksum === 0x12345678) console.log("Impossible checksum");
          }

          // Use median of measurements to reduce noise
          measurements.sort((a, b) => a - b);
          const avgExecutionTime =
            measurements[Math.floor(measurements.length / 2)];

          // Store performance data
          if (!performanceData[testConfig.file]) {
            performanceData[testConfig.file] = {};
          }
          performanceData[testConfig.file][mode.enabled ? 'inline' : 'no-inline'] = avgExecutionTime;

          // Update table cells
          const output_cell = table_row.cells[4];
          const expected_cell = table_row.cells[5];
          const performance_cell = table_row.cells[6];

          output_cell.textContent = result;
          expected_cell.textContent = testConfig.expected;
          performance_cell.textContent = formatTime(avgExecutionTime);

          // Check the result against expected output
          if (result === testConfig.expected) {
            status_cell.textContent = "PASS";
            status_cell.className = "result pass";
            pass_count++;

            // Add performance comparison for inlined version
            if (mode.enabled && performanceData[testConfig.file]['no-inline']) {
              const baseTime = performanceData[testConfig.file]['no-inline'];
              const perfClass = getPerformanceClass(
                baseTime,
                avgExecutionTime,
                mode.enabled
              );
              const perfText = getPerformanceText(
                baseTime,
                avgExecutionTime,
                mode.enabled
              );

              performance_cell.innerHTML = `
                <div class="time-comparison">
                  <span>${formatTime(avgExecutionTime)}</span>
                  <span class="time-badge ${perfClass}">${perfText}</span>
                </div>
              `;
            }
          } else {
            status_cell.textContent = "FAIL";
            status_cell.className = "result fail";
            fail_count++;
          }

          updateSummary();
        } catch (error) {
          // Display any error
          const status_cell = table_row.cells[3];
          status_cell.textContent = "ERROR";
          status_cell.className = "result error";

          const output_cell = table_row.cells[4];
          output_cell.colSpan = 3;
          output_cell.textContent = `ERROR: ${error.message}`;

          error_count++;
          updateSummary();
        }
      }

      function createPerformanceSummary() {
        const summaryDiv = document.getElementById("performance-summary");
        let summaryHTML =
          '<div class="summary-box"><h3>Performance Summary</h3>';

        for (const [testFile, data] of Object.entries(performanceData)) {
          const testConfig = testConfigs.find(
            (config) => config.file === testFile
          );
          if (!testConfig) continue;

          summaryHTML += `<div class="test-group">`;
          summaryHTML += `<h4>${testConfig.name}</h4>`;
          summaryHTML += `<p class="performance-info">${testConfig.description}</p>`;

          if (data['no-inline'] && data['inline']) {
            summaryHTML +=
              '<table style="width: 100%; border-collapse: collapse;">';
            summaryHTML +=
              '<tr style="background-color: #f0f0f0;"><th style="padding: 5px; border: 1px solid #ddd;">Mode</th><th style="padding: 5px; border: 1px solid #ddd;">Avg Time</th><th style="padding: 5px; border: 1px solid #ddd;">vs Baseline</th></tr>';

            const baseTime = data['no-inline'];
            const inlineTime = data['inline'];

            // No-inline row
            summaryHTML += `<tr>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;">Without Inlining</td>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;">${formatTime(baseTime)}</td>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;"><span class="time-badge same">Baseline</span></td>`;
            summaryHTML += `</tr>`;

            // Inline row
            const perfText = getPerformanceText(baseTime, inlineTime, true);
            const perfClass = getPerformanceClass(baseTime, inlineTime, true);
            
            summaryHTML += `<tr>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;">With Inlining</td>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;">${formatTime(inlineTime)}</td>`;
            summaryHTML += `<td style="padding: 5px; border: 1px solid #ddd;"><span class="time-badge ${perfClass}">${perfText}</span></td>`;
            summaryHTML += `</tr>`;

            summaryHTML += "</table>";
          }
          summaryHTML += "</div>";
        }

        summaryHTML += "</div>";
        summaryDiv.innerHTML = summaryHTML;
      }

      // Run tests asynchronously
      function runTestsAsync() {
        const results_table = document.getElementById("results-table");

        for (const testConfig of testConfigs) {
          // Add a header row for each test group
          const headerRow = results_table.insertRow();
          headerRow.style.backgroundColor = "#e9ecef";
          headerRow.style.fontWeight = "bold";
          const headerCell = headerRow.insertCell(0);
          headerCell.colSpan = 7;
          headerCell.textContent = `${testConfig.name} - ${testConfig.description}`;

          for (const mode of inliningModes) {
            const row = results_table.insertRow();
            row.classList.add("inline-row", mode.enabled ? "with-inlining" : "without-inlining");

            // Test file
            const fileCell = row.insertCell(0);
            fileCell.textContent = `${testConfig.file}${mode.suffix}.wasm`;

            // Function name
            const funcCell = row.insertCell(1);
            funcCell.textContent = testConfig.function;

            // Inlining mode
            const modeCell = row.insertCell(2);
            modeCell.textContent = mode.name;
            modeCell.style.fontWeight = "bold";

            // Status
            const statusCell = row.insertCell(3);
            statusCell.textContent = "Waiting...";
            statusCell.className = "result waiting";

            // Output
            row.insertCell(4);

            // Expected
            row.insertCell(5);

            // Performance
            row.insertCell(6);

            // Run the test asynchronously
            runTest(testConfig, mode, row);
          }
        }

        // Generate performance summary after a delay to allow tests to complete
        setTimeout(createPerformanceSummary, 3000);
      }

      // Start the tests
      runTestsAsync();
    </script>
  </body>
</html>