<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tail Recursion Optimization Tests</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      .nav {
        background-color: #f5f5f5;
        border-radius: 4px;
        padding: 8px 12px;
        margin: 12px 0;
      }
      .nav a {
        margin-right: 12px;
        text-decoration: none;
        color: #0366d6;
      }
      .nav a.active {
        font-weight: bold;
        color: #000;
      }
      .test {
        margin-bottom: 20px;
      }
      .test-group {
        border: 1px solid #ddd;
        border-radius: 5px;
        margin: 20px 0;
        padding: 15px;
      }
      .test-group h3 {
        margin-top: 0;
        color: #333;
      }
      .inline-row {
        background-color: #f9f9f9;
        border-left: 4px solid #007acc;
      }
      .with-inlining {
        background-color: #f0fff0;
      }
      .without-inlining {
        background-color: #fff8dc;
      }
      .error {
        color: red;
        font-weight: bold;
      }
      .pass {
        color: darkgreen;
        font-weight: bold;
      }
      .fail {
        color: darkred;
        font-weight: bold;
      }
      .warn {
        color: #b58900;
        font-weight: bold;
      }
      .waiting {
        color: gray;
        font-style: italic;
      }
      .performance-info {
        font-size: 0.9em;
        color: #666;
        font-style: italic;
      }
      .summary-box {
        background-color: #e8f4f8;
        border: 1px solid #bee5eb;
        border-radius: 5px;
        padding: 15px;
        margin: 20px 0;
      }
      .time-comparison {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .time-badge {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
      }
      .faster {
        background-color: #d4edda;
        color: #155724;
      }
      .slower {
        background-color: #f8d7da;
        color: #721c24;
      }
      .same {
        background-color: #e2e3e5;
        color: #383d41;
      }
    </style>
  </head>
  <body>
    <h1>Tail Recursion Optimization Tests</h1>

    <div class="nav">
      <a href="../index.html">Project 4 Tests</a>
      <a href="../P3-tester.html">Project 3 Tests</a>
      <a href="../function-inlining/function-inlining-tester.html"
        >Function Inlining Tests</a
      >
      <a href="../loop-unrolling/loop-unrolling-tester.html"
        >Loop Unrolling Tests</a
      >
      <a class="active" href="tail-recursion-tester.html"
        >Tail Recursion Tests</a
      >
    </div>

    <div class="summary-box" id="env">
      <div
        style="display: flex; gap: 12px; flex-wrap: wrap; align-items: center"
      >
        <div><b>Browser:</b> <span id="ua"></span></div>
        <div><b>Timestamp:</b> <span id="ts"></span></div>
        <div>
          <label>Warm‑up</label>
          <input
            id="warmup"
            type="number"
            min="0"
            step="1"
            value="10"
            style="width: 72px"
          />
        </div>
        <div>
          <label>Runs</label>
          <input
            id="runs"
            type="number"
            min="1"
            step="1"
            value="5"
            style="width: 72px"
          />
        </div>
        <div>
          <label>Iterations/run</label>
          <input
            id="iters"
            type="number"
            min="1"
            step="1"
            value="5000"
            style="width: 96px"
          />
        </div>
        <button id="run">Run Tests</button>
        <button id="csv">Export CSV</button>
      </div>
      <div class="performance-info" style="margin-top: 6px">
        Each case is compiled in two variants (off vs loop). Timing reports
        median over N runs and excludes warm‑up. Percent change is loop vs off.
        Ensure the corresponding <code>-off.wasm</code> and
        <code>-loop.wasm</code> files are present (generated by
        <code>./make test</code> or
        <code>tests/tail-recursion/run_tail_tests.sh</code>).
      </div>
    </div>

    <table id="tbl">
      <tr style="height: 30px">
        <td style="background-color: #ddddff" colspan="6">
          <div id="test-summary">
            <b>Summary:</b> <span id="sum">0/0</span> passed
          </div>
        </td>
      </tr>
      <tr style="background-color: #dddddd">
        <th>Test</th>
        <th>Function</th>
        <th>Expected</th>
        <th>Status</th>
        <th>Time</th>
        <th>Performance</th>
      </tr>
    </table>

    <script>
      const cases = [
        {
          base: "tail-test-01",
          fn: "main",
          expected: 235,
          note: "factorial accumulator (small - baseline)",
        },
        {
          base: "tail-test-02", 
          fn: "main", 
          expected: 5050, 
          note: "sum to 100 (medium recursion depth)"
        },
        {
          base: "tail-test-03",
          fn: "main",
          expected: 500500,
          note: "sum accumulator (no parameter cycles)",
        },
        { 
          base: "tail-test-04", 
          fn: "main", 
          expected: 6, 
          note: "gcd(48,18) - iterative style"
        },
        {
          base: "tail-test-05",
          fn: "main",
          expected: 1048576,
          note: "pow_acc(2,20) - mathematical computation",
        },
        {
          base: "tail-test-deep-01",
          fn: "main",
          expected: 50005000,
          note: "deep sum to 10000 (very high stack pressure)",
        },
        {
          base: "tail-test-deep-02",
          fn: "main", 
          expected: 102334155,
          note: "fibonacci(40) - deep recursion stress test"
        },
        {
          base: "tail-test-deep-03",
          fn: "main",
          expected: 50005000,
          note: "countdown from 10000 (very stack intensive)"
        },
        {
          base: "tail-test-extreme",
          fn: "main",
          expected: 1048576,
          note: "power calculation (2^20) - computational stress"
        },
        {
          base: "tail-test-order",
          fn: "main",
          expected: 8,
          note: "argument evaluation order preserves fibonacci progression"
        },
        {
          base: "tail-test-stress-01",
          fn: "main",
          expected: "__baseline__",
          note: "very deep tail recursion with heavy computation (50K levels)"
        },
        {
          base: "tail-test-stress-02",
          fn: "main",
          expected: "__baseline__",
          note: "fibonacci with very deep tail recursion (100K levels)"
        },
        {
          base: "tail-test-stress-03",
          fn: "main",
          expected: "__baseline__",
          note: "complex mathematical tail recursion (50K levels)"
        },
        {
          base: "tail-test-stress-04",
          fn: "main",
          expected: "__baseline__",
          note: "multiple tail recursive calls (75K levels)"
        },
        {
          base: "tail-test-stress-05",
          fn: "main",
          expected: "__baseline__",
          note: "extreme depth tail recursion (100K levels)"
        }
      ];

      const rows = new Map();
      const data = [];

      function fmt(ms) {
        return ms < 1000 ? ms.toFixed(2) + "ms" : (ms / 1000).toFixed(3) + "s";
      }
      function badge(off, loop) {
        if (!off || !loop) return "";
        const d = ((loop - off) / off) * 100;
        const cls = d > 0 ? "slower" : d < 0 ? "faster" : "same";
        const sign = d > 0 ? "+" : "";
        return `<span class="${cls}">${sign}${d.toFixed(1)}%</span>`;
      }

      function percentile(a, p) {
        if (!a.length) return NaN;
        const k = (a.length - 1) * p;
        const f = Math.floor(k),
          c = Math.ceil(k);
        if (f === c) return a[f];
        return a[f] + (a[c] - a[f]) * (k - f);
      }

      async function loadWasm(path) {
        const res = await fetch(path);
        if (!res.ok) throw new Error("Missing " + path);
        const buf = await res.arrayBuffer();
        const mod = await WebAssembly.instantiate(buf);
        return { inst: mod.instance, bytes: buf.byteLength };
      }

      async function runOne(base, fn, variant) {
        const wasm = await loadWasm(`${base}-${variant}.wasm`);
        const f = wasm.inst.exports[fn];
        const warmup =
          parseInt(document.getElementById("warmup").value, 10) || 10;
        const runs = parseInt(document.getElementById("runs").value, 10) || 5;
        const iters =
          parseInt(document.getElementById("iters").value, 10) || 100;
        for (let i = 0; i < warmup; i++) f();
        const times = [];
        let last = 0;
        for (let r = 0; r < runs; r++) {
          const t0 = performance.now();
          let checksum = 0;
          for (let i = 0; i < iters; i++) {
            last = f();
            checksum ^= last;
          }
          const t1 = performance.now();
          times.push((t1 - t0) / iters);
          if (checksum === 0x12345678) console.log("avoid dce");
        }
        times.sort((a, b) => a - b);
        return {
          p50: times[Math.floor(times.length / 2)],
          p25: percentile(times, 0.25),
          p75: percentile(times, 0.75),
          out: last,
          bytes: wasm.bytes,
        };
      }

      async function runAll() {
        const tbl = document.getElementById("tbl");
        // reset table rows beyond header
        for (let i = tbl.rows.length - 1; i >= 2; --i) tbl.deleteRow(i);
        rows.clear();
        data.length = 0;
        let passed = 0;

        for (const tc of cases) {
          // Add a header row for each test case
          const headerRow = tbl.insertRow();
          headerRow.style.backgroundColor = "#e9ecef";
          headerRow.style.fontWeight = "bold";
          const headerCell = headerRow.insertCell(0);
          headerCell.colSpan = 6;
          headerCell.textContent = `${tc.base} - ${
            tc.note || "tail recursion test"
          }`;

          // Create row for 'off' variant
          const rowOff = tbl.insertRow();
          rowOff.classList.add("without-inlining");
          rows.set(tc.base + "-off", rowOff);

          rowOff.insertCell(0).textContent = `${tc.base}-off.wasm`;
          rowOff.insertCell(1).textContent = tc.fn;
          rowOff.insertCell(2).textContent =
            tc.expected === "__baseline__" ? "(baseline)" : tc.expected;
          const stOff = rowOff.insertCell(3);
          const tOff = rowOff.insertCell(4);
          rowOff.insertCell(5).textContent = "—"; // Performance baseline

          // Create row for 'loop' variant
          const rowLoop = tbl.insertRow();
          rowLoop.classList.add("with-inlining");
          rows.set(tc.base + "-loop", rowLoop);

          rowLoop.insertCell(0).textContent = `${tc.base}-loop.wasm`;
          rowLoop.insertCell(1).textContent = tc.fn;
          rowLoop.insertCell(2).textContent =
            tc.expected === "__baseline__" ? "(baseline)" : tc.expected;
          const stLoop = rowLoop.insertCell(3);
          const tLoop = rowLoop.insertCell(4);
          const delta = rowLoop.insertCell(5);

          stOff.textContent = stLoop.textContent = "Waiting...";
          stOff.className = stLoop.className = "waiting";

          const useBaseline = tc.expected === "__baseline__";
          let expectedValue = useBaseline ? null : tc.expected;
          let offResult = null;
          let loopResult = null;
          let offError = null;
          let loopError = null;

          try {
            offResult = await runOne(tc.base, tc.fn, "off");
          } catch (err) {
            offError = err;
          }

          if (offResult) {
            if (useBaseline) expectedValue = offResult.out;
            tOff.textContent = fmt(offResult.p50);
            if (expectedValue !== null && offResult.out === expectedValue) {
              stOff.textContent = "PASS";
              stOff.className = "pass";
            } else {
              stOff.textContent = `FAIL (got ${offResult.out})`;
              stOff.className = "fail";
            }
          } else {
            tOff.textContent = "—";
            stOff.textContent = offError
              ? `ERR: ${offError.message}`
              : "UNAVAILABLE";
            stOff.className = useBaseline ? "warn" : "fail";
          }

          try {
            loopResult = await runOne(tc.base, tc.fn, "loop");
          } catch (err) {
            loopError = err;
          }

          if (loopResult) {
            if (expectedValue === null) expectedValue = loopResult.out;
            tLoop.textContent = fmt(loopResult.p50);
            if (expectedValue !== null && loopResult.out === expectedValue) {
              stLoop.textContent = "PASS";
              stLoop.className = "pass";
            } else {
              stLoop.textContent = `FAIL (got ${loopResult.out})`;
              stLoop.className = "fail";
            }
          } else {
            tLoop.textContent = "—";
            stLoop.textContent = loopError
              ? `ERR: ${loopError.message}`
              : "UNAVAILABLE";
            stLoop.className = "fail";
          }

          if (offResult && loopResult) {
            delta.innerHTML = badge(offResult.p50, loopResult.p50);
          } else {
            delta.textContent = "—";
          }

          const loopPass =
            loopResult && expectedValue !== null && loopResult.out === expectedValue;
          const offPass =
            offResult && expectedValue !== null && offResult.out === expectedValue;
          if (loopPass && (offResult ? offPass : useBaseline)) {
            passed++;
          }

          data.push({
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            base: tc.base,
            fn: tc.fn,
            note: tc.note || "",
            expected: expectedValue,
            off_ms: offResult ? offResult.p50 : null,
            off_p25: offResult ? offResult.p25 : null,
            off_p75: offResult ? offResult.p75 : null,
            off_bytes: offResult ? offResult.bytes : 0,
            loop_ms: loopResult ? loopResult.p50 : null,
            loop_p25: loopResult ? loopResult.p25 : null,
            loop_p75: loopResult ? loopResult.p75 : null,
            loop_bytes: loopResult ? loopResult.bytes : 0,
            out_off: offResult
              ? offResult.out
              : offError
              ? offError.message
              : null,
            out_loop: loopResult
              ? loopResult.out
              : loopError
              ? loopError.message
              : null,
          });
        }
        document.getElementById(
          "sum"
        ).textContent = `${passed}/${cases.length}`;
      }

      function setup() {
        document.getElementById("ua").textContent = navigator.userAgent;
        document.getElementById("ts").textContent = new Date().toLocaleString();
        document.getElementById("run").onclick = runAll;
        document.getElementById("csv").onclick = () => {
          const header = [
            "timestamp",
            "userAgent",
            "base",
            "note",
            "fn",
            "expected",
            "off_ms",
            "off_p25",
            "off_p75",
            "off_bytes",
            "loop_ms",
            "loop_p25",
            "loop_p75",
            "loop_bytes",
            "out_off",
            "out_loop",
          ];
          const rows = [header.join(",")].concat(
            data.map((r) =>
                  [
                    r.timestamp,
                    r.userAgent,
                    r.base,
                    r.note,
                    r.fn,
                r.expected,
                r.off_ms,
                r.off_p25,
                r.off_p75,
                r.off_bytes,
                r.loop_ms,
                r.loop_p25,
                r.loop_p75,
                r.loop_bytes,
                r.out_off,
                r.out_loop,
              ]
                .map((v) => String(v).replace(/"/g, '""'))
                .map((v) => (/[,"]/.test(v) ? `"${v}"` : v))
                .join(",")
            )
          );
          const blob = new Blob([rows.join("\n")], { type: "text/csv" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `tail-recursion-results-${Date.now()}.csv`;
          a.click();
          URL.revokeObjectURL(url);
        };
      }
      setup();
    </script>
  </body>
</html>
