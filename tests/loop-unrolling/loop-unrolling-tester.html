<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Loop Unrolling Performance Tests</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      .nav {
        background-color: #f5f5f5;
        border-radius: 4px;
        padding: 8px 12px;
        margin: 12px 0;
      }
      .nav a {
        margin-right: 12px;
        text-decoration: none;
        color: #0366d6;
      }
      .nav a.active {
        font-weight: bold;
        color: #000;
      }
      .test {
        margin-bottom: 20px;
      }
      .test-group {
        border: 1px solid #ddd;
        border-radius: 5px;
        margin: 20px 0;
        padding: 15px;
      }
      .test-group h3 {
        margin-top: 0;
        color: #333;
      }
      .unroll-row {
        background-color: #f9f9f9;
        border-left: 4px solid #007acc;
      }
      .factor-1 {
        background-color: #fff8dc;
      }
      .factor-4 {
        background-color: #f0f8ff;
      }
      .factor-8 {
        background-color: #f0fff0;
      }
      .factor-16 {
        background-color: #fff0f5;
      }
      .error {
        color: red;
        font-weight: bold;
      }
      .pass {
        color: darkgreen;
        font-weight: bold;
      }
      .fail {
        color: darkred;
        font-weight: bold;
      }
      .waiting {
        color: gray;
        font-style: italic;
      }
      .performance-info {
        font-size: 0.9em;
        color: #666;
        font-style: italic;
      }
      .summary-box {
        background-color: #e8f4f8;
        border: 1px solid #bee5eb;
        border-radius: 5px;
        padding: 15px;
        margin: 20px 0;
      }
      .time-comparison {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .time-badge {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
      }
      .faster {
        background-color: #d4edda;
        color: #155724;
      }
      .slower {
        background-color: #f8d7da;
        color: #721c24;
      }
      .same {
        background-color: #e2e3e5;
        color: #383d41;
      }
    </style>
  </head>
  <body>
    <h1>Loop Unrolling Performance Tests</h1>

    <div class="summary-box" id="env-box" style="margin-top: 10px">
      <div
        style="display: flex; gap: 16px; align-items: center; flex-wrap: wrap"
      >
        <div><b>Browser:</b> <span id="ua"></span></div>
        <div><b>Timestamp:</b> <span id="ts"></span></div>
      </div>
      <div
        style="
          margin-top: 8px;
          display: flex;
          gap: 12px;
          align-items: center;
          flex-wrap: wrap;
        "
      >
        <div>
          <label>Warm‑up</label>
          <input
            id="warmup"
            type="number"
            min="0"
            step="1"
            value="10"
            style="width: 72px"
          />
        </div>
        <div>
          <label>Runs</label>
          <input
            id="runs"
            type="number"
            min="1"
            step="1"
            value="5"
            style="width: 72px"
          />
        </div>
        <div>
          <label>Iterations / run</label>
          <input
            id="iters"
            type="number"
            min="1"
            step="1"
            value="100"
            style="width: 96px"
          />
        </div>
        <button id="rerun">Run Tests</button>
        <button id="export">Export CSV</button>
      </div>
      <div class="performance-info" style="margin-top: 6px">
        Timing reports median over N runs (configurable) and excludes warm‑up;
        percent changes are relative to the 1× baseline. CSV includes quartiles
        (p25/p75) and artifact sizes. Configure parameters, then select “Run
        Tests”.
      </div>
    </div>

    <div class="nav">
      <a href="../index.html">Project 4 Tests</a>
      <a href="../P3-tester.html">Project 3 Tests</a>
      <a href="../function-inlining/function-inlining-tester.html"
        >Function Inlining Tests</a
      >
      <a class="active" href="../loop-unrolling/loop-unrolling-tester.html"
        >Loop Unrolling Tests</a
      >
      <a href="../tail-recursion/tail-recursion-tester.html"
        >Tail Recursion Tests</a
      >
    </div>

    <table id="results-table">
      <tr style="height: 30px">
        <td style="background-color: #ddddff" colspan="7">
          <div id="test-summary">
            <b>TESTS:</b>
            <b><span class="total_count">0</span></b> &nbsp;&nbsp;&nbsp;
            <b>PASSED:</b>
            <span class="pass_count pass">0</span> &nbsp;&nbsp;&nbsp;
            <b>FAILED:</b>
            <span class="fail_count fail">0</span> &nbsp;&nbsp;&nbsp;
            <b>ERRORS:</b> <span class="error_count error">0</span>
          </div>
        </td>
      </tr>
      <tr style="background-color: #dddddd">
        <th>Test File</th>
        <th>Function</th>
        <th>Unroll Factor</th>
        <th>Status</th>
        <th>Output</th>
        <th>Expected</th>
        <th>Performance</th>
      </tr>
    </table>

    <div class="summary-box" style="margin-top: 20px">
      <h3 style="margin-top: 0">About These Tests</h3>
      <p>
        Measures the effect of loop unrolling on execution time using factors 1,
        4, 8, and 16. Each row reports median per‑call time after warm‑up;
        percent change is vs the 1× baseline.
      </p>
      <ul>
        <li>Timing: median of 3 runs × 100 iterations.</li>
        <li>Warm‑up: 10 iterations to stabilize JIT.</li>
        <li>Correctness: exact match with expected output.</li>
        <li>
          Note on CallsInLoop: when the loop body contains function calls, high
          unroll factors (8×–16×) can slow down due to larger loop bodies (more
          call sites per iteration), increased register pressure and spills,
          instruction‑cache effects, and less favorable JIT optimizations. In
          practice, a moderate factor (≈4×) is often the sweet spot.
        </li>
      </ul>
    </div>

    <script>
      // Test configurations for each file and unroll factor
      const testConfigs = [
        // UltraLight tests
        {
          file: "ultra-01",
          name: "UltraLight",
          function: "UltraLight",
          args: [],
          expected: 987459712,
          description: "Minimal loop body with maximum iterations (100M)",
        },
        // ParallelStreams tests
        {
          file: "ultra-02",
          name: "ParallelStreams",
          function: "ParallelStreams",
          args: [],
          expected: 1866094199, // Updated for 3M iterations with extra stream
          description: "Multiple independent calculations (3M)",
        },
        // RegisterPressure tests
        {
          file: "ultra-03",
          name: "RegisterPressure",
          function: "RegisterPressure",
          args: [],
          expected: 1473151831,
          description: "Many variables testing register allocation (1.5M)",
        },
        // MemoryAccess tests
        {
          file: "ultra-04",
          name: "MemoryAccess",
          function: "MemoryAccess",
          args: [],
          expected: 86372, // Complex memory access patterns (2M)
          description: "Memory access patterns with complex arithmetic (2M)",
        },
        // Function call in loop (regression for unrolling correctness)
        {
          file: "ultra-05",
          name: "CallsInLoop",
          function: "UsesCall",
          args: [],
          expected: 6000000,
          description: "Calls tiny function inside loop (2M)",
        },
      ];

      const unrollFactors = [1, 4, 8, 16];

      // Summary counters
      let test_count = 0;
      let pass_count = 0;
      let fail_count = 0;
      let error_count = 0;

      // Performance tracking
      const performanceData = {};
      // Map of rows to enable retroactive perf badge updates: file -> factor -> row
      const rowsByFileFactor = {};
      // Collected records for CSV export
      const collected = [];

      function updateSummary() {
        const summary_div = document.getElementById("test-summary");
        const tot_span = summary_div.querySelector(".total_count");
        tot_span.textContent = test_count;
        const pass_span = summary_div.querySelector(".pass_count");
        pass_span.textContent = pass_count;
        const fail_span = summary_div.querySelector(".fail_count");
        fail_span.textContent = fail_count;
        const error_span = summary_div.querySelector(".error_count");
        error_span.textContent = error_count;
      }

      function formatTime(ms) {
        if (ms < 1000) {
          return `${ms.toFixed(2)}ms`;
        } else {
          return `${(ms / 1000).toFixed(3)}s`;
        }
      }

      function getPerformanceClass(factor, baseTime, currentTime) {
        if (!baseTime || !currentTime) return "same";
        const diff = ((currentTime - baseTime) / baseTime) * 100;
        if (factor === 1) return "same"; // Only baseline shows as "same"
        return diff > 0 ? "slower" : "faster";
      }

      function getPerformanceText(factor, baseTime, currentTime) {
        if (!baseTime || !currentTime || factor === 1) return "";
        const diff = ((currentTime - baseTime) / baseTime) * 100;
        const symbol = diff > 0 ? "+" : "";
        return `${symbol}${diff.toFixed(1)}%`;
      }

      // When baseline becomes available, fill in percent badges for finished rows
      function refreshRowPerformance(file) {
        if (!performanceData[file] || !performanceData[file][1]) return;
        const baseTime = performanceData[file][1];
        const rowMap = rowsByFileFactor[file] || {};

        for (const factor of unrollFactors) {
          if (factor === 1) continue;
          const time = performanceData[file][factor];
          const row = rowMap[factor];
          if (!time || !row) continue;

          const statusCell = row.cells[3];
          const performanceCell = row.cells[6];
          const timeText = formatTime(time);

          if (statusCell.textContent === "PASS") {
            const perfClass = getPerformanceClass(factor, baseTime, time);
            const perfText = getPerformanceText(factor, baseTime, time);
            performanceCell.innerHTML = `
              <div class="time-comparison">
                <span>${timeText}</span>
                <span class="time-badge ${perfClass}">${perfText}</span>
              </div>
            `;
          } else {
            // Keep plain time for non-PASS rows
            performanceCell.textContent = timeText;
          }
        }
      }

      function percentile(arr, p) {
        if (!arr.length) return NaN;
        const k = (arr.length - 1) * p;
        const f = Math.floor(k),
          c = Math.ceil(k);
        if (f === c) return arr[f];
        return arr[f] + (arr[c] - arr[f]) * (k - f);
      }

      // Function to load and test each WASM file
      async function runTest(testConfig, factor, table_row) {
        const filename = `${testConfig.file}-unroll${factor}.wasm`;

        try {
          test_count++;
          updateSummary();

          // Update status to show progress
          const status_cell = table_row.cells[3];
          status_cell.textContent = "Loading...";
          status_cell.className = "result waiting";

          // Fetch the WASM file
          const response = await fetch(filename);
          if (!response.ok) {
            throw new Error(`Missing file ${filename}`);
          }
          const wasmBuffer = await response.arrayBuffer();
          const wasmBytes = wasmBuffer.byteLength;
          const wasmModule = await WebAssembly.instantiate(wasmBuffer);

          // Try to fetch the matching WAT to record size (served by tests harness)
          let watBytes = 0;
          try {
            const watResp = await fetch(
              `${testConfig.file}-unroll${factor}.wat`
            );
            if (watResp.ok) {
              const watBuf = await watResp.arrayBuffer();
              watBytes = watBuf.byteLength;
            }
          } catch (_) {}

          // Update status to show testing in progress
          status_cell.textContent = "Testing...";

          // Execute the function multiple times to get more reliable timing (configurable)
          const iterations =
            parseInt(document.getElementById("iters").value, 10) || 100;
          const warmupIterations =
            parseInt(document.getElementById("warmup").value, 10) || 10;

          // Warm-up phase to stabilize JIT compilation
          for (let i = 0; i < warmupIterations; i++) {
            wasmModule.instance.exports[testConfig.function].apply(
              null,
              testConfig.args
            );
          }

          // Force garbage collection if available (Chrome DevTools)
          if (window.gc) {
            window.gc();
          }

          // Actual measurement phase with multiple runs
          const measurements = [];
          const runs = parseInt(document.getElementById("runs").value, 10) || 5;

          for (let run = 0; run < runs; run++) {
            const runStartTime = performance.now();
            let checksum = 0; // Prevent dead code elimination

            for (let i = 0; i < iterations; i++) {
              result = wasmModule.instance.exports[testConfig.function].apply(
                null,
                testConfig.args
              );
              checksum ^= result; // XOR to prevent optimization while staying fast
            }

            const runEndTime = performance.now();
            measurements.push((runEndTime - runStartTime) / iterations);

            // Use checksum to prevent dead code elimination
            if (checksum === 0x12345678) console.log("Impossible checksum");
          }

          // Use median and spread (IQR) to reduce/describe noise
          measurements.sort((a, b) => a - b);
          const p50 = measurements[Math.floor(measurements.length / 2)];
          const p25 = percentile(measurements, 0.25);
          const p75 = percentile(measurements, 0.75);
          const avgExecutionTime = p50;

          // Store performance data
          if (!performanceData[testConfig.file]) {
            performanceData[testConfig.file] = {};
          }
          performanceData[testConfig.file][factor] = avgExecutionTime;

          // Update table cells (reuse already declared status_cell)
          const output_cell = table_row.cells[4];
          const expected_cell = table_row.cells[5];
          const performance_cell = table_row.cells[6];

          output_cell.textContent = result;
          expected_cell.textContent = testConfig.expected;
          performance_cell.textContent = formatTime(avgExecutionTime);

          // Check the result against expected output
          if (result === testConfig.expected) {
            status_cell.textContent = "PASS";
            status_cell.className = "result pass";
            pass_count++;

            // Add performance comparison for factors > 1
            if (factor > 1 && performanceData[testConfig.file][1]) {
              const baseTime = performanceData[testConfig.file][1];
              const perfClass = getPerformanceClass(
                factor,
                baseTime,
                avgExecutionTime
              );
              const perfText = getPerformanceText(
                factor,
                baseTime,
                avgExecutionTime
              );

              performance_cell.innerHTML = `
                <div class="time-comparison">
                  <span>${formatTime(avgExecutionTime)}</span>
                  <span class="time-badge ${perfClass}">${perfText}</span>
                </div>
              `;
            }
            // Now that data is recorded, try to refresh other rows in this group
            refreshRowPerformance(testConfig.file);
          } else {
            status_cell.textContent = "FAIL";
            status_cell.className = "result fail";
            fail_count++;
          }

          updateSummary();

          // Record for CSV export
          collected.push({
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            file: `${testConfig.file}`,
            function: testConfig.function,
            factor,
            time_ms: avgExecutionTime,
            p25_ms: p25,
            p75_ms: p75,
            wasm_bytes: wasmBytes,
            wat_bytes: watBytes,
            output: String(result),
            expected: String(testConfig.expected),
            status: result === testConfig.expected ? "PASS" : "FAIL",
          });
        } catch (error) {
          // Display any error
          const status_cell = table_row.cells[3];
          status_cell.textContent = "ERROR";
          status_cell.className = "result error";

          const output_cell = table_row.cells[4];
          output_cell.colSpan = 3;
          output_cell.textContent = `ERROR: ${error.message}`;

          error_count++;
          updateSummary();
        }
      }

      // Run tests asynchronously
      function runTestsAsync() {
        const results_table = document.getElementById("results-table");

        // Reset counters and rows
        test_count = pass_count = fail_count = error_count = 0;
        for (let i = results_table.rows.length - 1; i >= 2; --i) {
          results_table.deleteRow(i);
        }
        updateSummary();
        collected.length = 0;
        for (const k in performanceData) delete performanceData[k];
        for (const k in rowsByFileFactor) delete rowsByFileFactor[k];

        for (const testConfig of testConfigs) {
          // Add a header row for each test group
          const headerRow = results_table.insertRow();
          headerRow.style.backgroundColor = "#e9ecef";
          headerRow.style.fontWeight = "bold";
          const headerCell = headerRow.insertCell(0);
          headerCell.colSpan = 7;
          headerCell.textContent = `${testConfig.name} - ${testConfig.description}`;

          for (const factor of unrollFactors) {
            const row = results_table.insertRow();
            row.classList.add("unroll-row", `factor-${factor}`);

            // Test file
            const fileCell = row.insertCell(0);
            fileCell.textContent = `${testConfig.file}-unroll${factor}.wasm`;

            // Function name
            const funcCell = row.insertCell(1);
            funcCell.textContent = testConfig.function;

            // Unroll factor
            const factorCell = row.insertCell(2);
            factorCell.textContent = `${factor}x`;
            factorCell.style.fontWeight = "bold";

            // Status
            const statusCell = row.insertCell(3);
            statusCell.textContent = "Waiting...";
            statusCell.className = "result waiting";

            // Output
            row.insertCell(4);

            // Expected
            row.insertCell(5);

            // Performance
            row.insertCell(6);

            // Run the test asynchronously
            if (!rowsByFileFactor[testConfig.file]) {
              rowsByFileFactor[testConfig.file] = {};
            }
            rowsByFileFactor[testConfig.file][factor] = row;
            runTest(testConfig, factor, row);
          }
        }
      }

      // Start the tests
      function setupEnvBox() {
        document.getElementById("ua").textContent = navigator.userAgent;
        const ts = new Date();
        document.getElementById("ts").textContent = ts.toLocaleString();
        document.getElementById("rerun").onclick = () => runTestsAsync();
        document.getElementById("export").onclick = () => {
          const header = [
            "timestamp",
            "userAgent",
            "file",
            "function",
            "factor",
            "time_ms",
            "p25_ms",
            "p75_ms",
            "wasm_bytes",
            "wat_bytes",
            "output",
            "expected",
            "status",
          ];
          const rows = [header.join(",")].concat(
            collected.map((r) =>
              [
                r.timestamp,
                r.userAgent,
                r.file,
                r.function,
                r.factor,
                r.time_ms,
                r.p25_ms,
                r.p75_ms,
                r.wasm_bytes,
                r.wat_bytes,
                r.output,
                r.expected,
                r.status,
              ]
                .map((v) => String(v).replace(/"/g, '""'))
                .map((v) => (/[,"]/g.test(v) ? `"${v}"` : v))
                .join(",")
            )
          );
          const blob = new Blob([rows.join("\n")], { type: "text/csv" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `loop-unrolling-results-${Date.now()}.csv`;
          a.click();
          URL.revokeObjectURL(url);
        };
      }

      setupEnvBox();
    </script>
  </body>
</html>
